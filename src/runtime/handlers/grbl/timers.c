/* ##############   Includes   ############## */
#include <surgeon/runtime.h>
#include <surgeon/symbols.h>
#include <surgeon/timer.h>
#include <stdint.h>

/* #########   Function signatures   ######## */
static void USED grbl_timers_step_timer_init(void);
static void USED grbl_timers_tim2_irqhandler(void);

/* ###############   Globals   ############## */
static const uint32_t tim2_irqn =
    EXTI_BASE + 28; /* 28 = IRQn, offset 16 for external interrupts */
/* Weak function declarations for firmware functions, might be strongly declared
 * in the autogenerated code */
WEAK generic_func_t _step_delay_isr;
WEAK generic_func_t _step_pulse_isr;
WEAK generic_func_t _step_period_isr;

/**
 * @brief Initialize the step timer for the grbl CNC firmware
 */
static void USED grbl_timers_step_timer_init(void) {
    /* For now, add a timer that fires every ~10000 instructions */
    size_t timer_num = add_timer(10000, DYNINC);
    if (unlikely(timer_num == (size_t)-1)) {
        fprintf(stderr, "[%s] Adding timer failed\n", __func__);
        abort();
    }
    attach_irq(timer_num, tim2_irqn);
    start_timer(timer_num);
}

/**
 * @brief Handle interrupts for the step timer
 *
 * The function mimics the original interrupt handler by dispatching to the
 * firmware functions changing stepper behavior. However, we do that on a
 * round-robin basis instead of based on a timer output compare.
 */
static void USED grbl_timers_tim2_irqhandler(void) {
    static int func = 0;
    void (*step_delay_isr)(void) = (void (*)(void))_step_delay_isr;
    void (*step_period_isr)(void) = (void (*)(void))_step_period_isr;
    void (*step_pulse_isr)(void) = (void (*)(void))_step_pulse_isr;

    /* Round-robin dispatch to the different ISRs because we don't model the
     * corresponding timer status register at the moment */
    switch (func) {
        case 0: {
            step_delay_isr();
            break;
        }
        case 1: {
            step_period_isr();
            break;
        }
        case 2: {
            step_pulse_isr();
            break;
        }
        default: {
            abort();
        }
    }
    func++;
    func %= 3;
}
